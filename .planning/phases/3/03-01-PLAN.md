---
phase: 03-attention-hooks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/hook-manager.ts
  - src/main/main.ts
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "smol-toml is listed as a production dependency in package.json"
    - "codex-notify-hook.sh is created at ~/.bismarck/hooks/ (or ~/.bismarck-dev/hooks/) at app startup"
    - "codex-notify-hook.sh receives JSON as argv[1], extracts cwd, hashes it, reads mapping file, sends stop event to socket"
    - "configureCodexHook() writes notify entry to ~/.codex/config.toml only when codex binary exists AND at least one agent has provider=codex"
    - "configureCodexHook() is idempotent -- does not duplicate entries on repeated runs"
    - "configureCodexHook() does not clobber existing user settings in config.toml"
    - "configureCodexHook() is called at app startup in main.ts"
    - "TypeScript compiles with zero errors after all changes"
  artifacts:
    - path: "src/main/hook-manager.ts"
      provides: "createCodexNotifyHookScript(), configureCodexHook(), getCodexNotifyHookScriptPath()"
      contains: "configureCodexHook"
    - path: "src/main/main.ts"
      provides: "Startup call to configureCodexHook alongside configureClaudeHook"
      contains: "configureCodexHook"
    - path: "package.json"
      provides: "smol-toml dependency"
      contains: "smol-toml"
  key_links:
    - from: "src/main/main.ts"
      to: "src/main/hook-manager.ts"
      via: "imports and calls configureCodexHook"
      pattern: "configureCodexHook"
    - from: "src/main/hook-manager.ts"
      to: "src/main/config.ts"
      via: "imports getConfigDir for hook script path"
      pattern: "getConfigDir"
    - from: "src/main/hook-manager.ts"
      to: "src/main/exec-utils.ts"
      via: "imports hasBinary to check if codex is installed"
      pattern: "hasBinary"
---

<objective>
Install smol-toml dependency, create the Codex notify hook script, implement configureCodexHook() in hook-manager.ts, and wire it up at app startup in main.ts.

Purpose: This is the hook registration side of Phase 3. It enables Bismarck to register itself as a notify callback in Codex's config.toml, so Codex agent turn-complete events reach Bismarck's attention system.

Output: smol-toml installed, codex-notify-hook.sh created alongside existing Claude hooks, configureCodexHook() registered at startup.
</objective>

<execution_context>
@/workspace/CLAUDE.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3/CONTEXT.md
@.planning/phases/3/03-RESEARCH.md
@src/main/hook-manager.ts
@src/main/main.ts
@src/main/config.ts
@src/main/exec-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install smol-toml dependency</name>
  <files>package.json, package-lock.json</files>
  <action>
Run `npm install smol-toml` from /workspace to add the TOML parsing library as a production dependency. This library is needed for reading and writing `~/.codex/config.toml` in configureCodexHook().

Do NOT install as a devDependency — it's used at runtime in the main process.
  </action>
  <verify>
- `grep "smol-toml" package.json` shows the dependency with a version like `^1.x.x`
- `ls node_modules/smol-toml/` confirms the package is installed
- `npx tsc --noEmit` still passes (no type conflicts)
  </verify>
  <done>smol-toml is listed in package.json dependencies and installed in node_modules.</done>
</task>

<task type="auto">
  <name>Task 2: Add Codex hook script and configureCodexHook to hook-manager.ts</name>
  <files>src/main/hook-manager.ts</files>
  <action>
Add three new elements to `src/main/hook-manager.ts`:

**Step 1: Add new imports at the top of the file.**

Add these imports alongside the existing ones:

```typescript
import { parse, stringify } from 'smol-toml'
import { hasBinary } from './exec-utils'
import { getWorkspaces } from './config'
```

Also add a new constant for the Codex hook script name alongside the existing `HOOK_SCRIPT_NAME` etc.:

```typescript
const CODEX_NOTIFY_HOOK_SCRIPT_NAME = 'codex-notify-hook.sh'
```

**Step 2: Add `getCodexNotifyHookScriptPath()` function.**

Place alongside the existing `getHookScriptPath()`, `getNotificationHookScriptPath()`, etc.:

```typescript
function getCodexNotifyHookScriptPath(): string {
  return path.join(getConfigDir(), 'hooks', CODEX_NOTIFY_HOOK_SCRIPT_NAME)
}
```

**Step 3: Add `createCodexNotifyHookScript()` function.**

Place after the existing `createPersonaModeHookScript()` and before `configureClaudeHook()`. The hook script:

1. Receives JSON from Codex as argv[1]
2. Extracts `cwd` from the JSON
3. Hashes the cwd (SHA-256, first 16 hex chars) to find the mapping file
4. Reads workspaceId and instanceId from the mapping file
5. Sends a stop event to the Bismarck Unix socket

```typescript
export function createCodexNotifyHookScript(): void {
  const configDirName = getConfigDirName()
  const hookScript = `#!/bin/bash
# Bismarck Codex notify hook - signals when Codex agent needs input
# Receives JSON payload as argv[1] from Codex notify callback

JSON="$1"
[ -z "$JSON" ] && exit 0

# Extract cwd from JSON payload using grep (no jq dependency)
CWD=$(printf '%s' "$JSON" | grep -o '"cwd":"[^"]*"' | head -1 | cut -d'"' -f4)
[ -z "$CWD" ] && exit 0

# Hash the cwd to find the mapping file (SHA-256, first 16 hex chars)
HASH=$(printf '%s' "$CWD" | shasum -a 256 | cut -c1-16)
MAPPING="$HOME/${configDirName}/sessions/codex-\${HASH}.json"
[ ! -f "$MAPPING" ] && exit 0

# Read workspaceId and instanceId from mapping file
WORKSPACE_ID=$(grep -o '"workspaceId":"[^"]*"' "$MAPPING" | cut -d'"' -f4)
INSTANCE_ID=$(grep -o '"instanceId":"[^"]*"' "$MAPPING" | cut -d'"' -f4)
[ -z "$WORKSPACE_ID" ] || [ -z "$INSTANCE_ID" ] && exit 0

# Send stop event to Bismarck socket
SOCKET_PATH="/tmp/bm/\${INSTANCE_ID:0:8}/\${WORKSPACE_ID:0:8}.sock"
[ -S "$SOCKET_PATH" ] && printf '{"event":"stop","reason":"input_required","workspaceId":"%s"}\\n' "$WORKSPACE_ID" | nc -U "$SOCKET_PATH" 2>/dev/null
exit 0
`

  const hookPath = getCodexNotifyHookScriptPath()
  fs.writeFileSync(hookPath, hookScript)
  fs.chmodSync(hookPath, '755')
}
```

**Step 4: Add `configureCodexHook()` function.**

Place after `configureClaudeHook()`. This function:
- Checks preconditions: codex binary exists AND at least one agent has `provider === 'codex'`
- Creates the hook script
- Reads `~/.codex/config.toml`, parses with smol-toml
- Checks if our notify entry already exists (idempotent)
- Adds `notify = ["/path/to/codex-notify-hook.sh"]` if not present
- Writes back the TOML config

Per CONTEXT.md pitfall #1: if user already has a notify entry that is NOT our script, log a warning and skip — do NOT overwrite.

```typescript
export function configureCodexHook(): void {
  // Only configure if codex binary is installed AND at least one agent uses codex
  if (!hasBinary('codex')) {
    return
  }

  const workspaces = getWorkspaces()
  const hasCodexAgent = workspaces.some(w => w.provider === 'codex')
  if (!hasCodexAgent) {
    return
  }

  // Create the hook script
  createCodexNotifyHookScript()

  const homeDir = app?.getPath('home') || process.env.HOME || ''
  const configPath = path.join(homeDir, '.codex', 'config.toml')
  const hookScriptPath = getCodexNotifyHookScriptPath()

  // Read existing config or start with empty
  let config: Record<string, unknown> = {}
  if (fs.existsSync(configPath)) {
    try {
      const content = fs.readFileSync(configPath, 'utf-8')
      config = parse(content)
    } catch (e) {
      console.error('Failed to parse Codex config.toml:', e)
      return
    }
  }

  // Check if notify is already configured
  const currentNotify = config.notify as string[] | undefined
  if (currentNotify && Array.isArray(currentNotify)) {
    if (currentNotify[0] === hookScriptPath) {
      // Already configured with our script — idempotent, nothing to do
      return
    }
    // User has a different notify command — do NOT overwrite
    devLog(`[HookManager] Codex config.toml already has notify configured: ${currentNotify[0]}. Skipping Bismarck hook installation.`)
    return
  }

  // Set our hook script as the notify command
  config.notify = [hookScriptPath]

  // Ensure ~/.codex/ directory exists
  const codexDir = path.dirname(configPath)
  if (!fs.existsSync(codexDir)) {
    fs.mkdirSync(codexDir, { recursive: true })
  }

  // Write updated config
  fs.writeFileSync(configPath, stringify(config))
  devLog('Configured Codex notify hook for Bismarck')
}
```

**Important design decisions reflected:**
- Per CONTEXT.md: Only install if BOTH codex binary exists AND at least one agent has provider=codex
- Per CONTEXT.md: Idempotent — check if our entry already exists before adding
- Per research pitfall #1: If user has different notify command, log warning and skip
- Per research pitfall #2: Only write config if we actually need to change it (avoids clobbering comments on no-op)
- Per research pitfall #5: Create ~/.codex/ directory if it doesn't exist
  </action>
  <verify>
- `npx tsc --noEmit` from /workspace passes with zero errors
- `grep -n "configureCodexHook" src/main/hook-manager.ts` shows the function definition
- `grep -n "createCodexNotifyHookScript" src/main/hook-manager.ts` shows the function definition
- `grep -n "getCodexNotifyHookScriptPath" src/main/hook-manager.ts` shows the function definition
- `grep -n "smol-toml" src/main/hook-manager.ts` shows the import
- `grep -n "hasBinary" src/main/hook-manager.ts` shows the import
- `grep -n "codex-notify-hook" src/main/hook-manager.ts` shows the script name constant
- `grep -n "shasum" src/main/hook-manager.ts` shows the hash command in the hook script
  </verify>
  <done>hook-manager.ts has createCodexNotifyHookScript() that creates the bash hook script, and configureCodexHook() that installs the notify callback in ~/.codex/config.toml. Both functions are exported. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: Wire configureCodexHook into app startup in main.ts</name>
  <files>src/main/main.ts</files>
  <action>
**Step 1: Update the import from hook-manager.ts.**

Find the existing import line:
```typescript
import { configureClaudeHook, createHookScript } from './hook-manager'
```

Add `configureCodexHook` to it:
```typescript
import { configureClaudeHook, configureCodexHook, createHookScript } from './hook-manager'
```

**Step 2: Call configureCodexHook at startup.**

Find the existing hook configuration lines (around line 1643-1644):
```typescript
  timeSync('main:createHookScript', 'main', () => createHookScript())
  timeSync('main:configureClaudeHook', 'main', () => configureClaudeHook())
```

Add the Codex hook configuration call immediately after:
```typescript
  timeSync('main:createHookScript', 'main', () => createHookScript())
  timeSync('main:configureClaudeHook', 'main', () => configureClaudeHook())
  timeSync('main:configureCodexHook', 'main', () => configureCodexHook())
```

This is a synchronous call (configureCodexHook is sync), matching the pattern of configureClaudeHook. It runs early in startup before the window is created.
  </action>
  <verify>
- `npx tsc --noEmit` from /workspace passes with zero errors
- `grep -n "configureCodexHook" src/main/main.ts` shows both the import and the call
- `grep -n "configureClaudeHook\|configureCodexHook" src/main/main.ts` shows both hook configurations adjacent
  </verify>
  <done>configureCodexHook() is called at app startup alongside configureClaudeHook(). Import updated. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `grep "smol-toml" package.json` shows the dependency
- [ ] `grep -n "configureCodexHook" src/main/hook-manager.ts` shows the exported function
- [ ] `grep -n "createCodexNotifyHookScript" src/main/hook-manager.ts` shows the exported function
- [ ] `grep -n "configureCodexHook" src/main/main.ts` shows the import and startup call
- [ ] `grep "codex-notify-hook" src/main/hook-manager.ts` shows the script name
- [ ] `grep "shasum" src/main/hook-manager.ts` shows hash in hook script template
- [ ] `grep "hasBinary.*codex" src/main/hook-manager.ts` shows the precondition check
- [ ] `grep "provider.*codex" src/main/hook-manager.ts` shows the agent filter check
- [ ] `grep "parse\|stringify" src/main/hook-manager.ts` shows TOML operations
</verification>

<success_criteria>
- smol-toml installed as production dependency
- codex-notify-hook.sh script template creates a bash script that:
  - Reads JSON from argv[1]
  - Extracts cwd field
  - Hashes cwd with SHA-256 (first 16 chars)
  - Reads mapping file from ~/.bismarck/sessions/codex-{hash}.json
  - Sends stop event to Unix socket
- configureCodexHook() is idempotent and checks preconditions
- configureCodexHook() does not overwrite user's existing notify setting
- configureCodexHook() called at startup alongside configureClaudeHook()
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/3/03-01-SUMMARY.md`
</output>
