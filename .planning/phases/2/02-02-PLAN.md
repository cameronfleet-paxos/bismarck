---
phase: 02-terminal-spawning
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/main/terminal.ts
autonomous: true

must_haves:
  truths:
    - "Codex agents spawn with `codex --cd <dir>` command when provider is 'codex'"
    - "Codex agents with initial prompt spawn with `codex --cd <dir> '<prompt>'`"
    - "Codex agents with existing sessionId resume with `codex resume <UUID> --cd <dir>`"
    - "Claude agents spawn identically to before (no behavioral change)"
    - "If codex binary not found, styled error message appears in terminal output"
    - "/clear detection only fires for Claude agents, not Codex"
    - "Claude ready detection (unicode triangle) only fires for Claude agents, not Codex"
    - "Codex session is discovered on terminal exit by scanning ~/.codex/sessions/"
  artifacts:
    - path: "src/main/terminal.ts"
      provides: "Provider-aware createTerminal with Codex command building, session management, and binary detection"
      exports: ["createTerminal"]
      contains: "buildCodexCommand"
  key_links:
    - from: "src/main/terminal.ts"
      to: "src/shared/types.ts"
      via: "imports getAgentProvider, AgentProvider"
      pattern: "getAgentProvider"
    - from: "src/main/terminal.ts"
      to: "src/main/exec-utils.ts"
      via: "imports findBinary for codex detection"
      pattern: "findBinary"
    - from: "src/main/terminal.ts"
      to: "src/main/config.ts"
      via: "saveWorkspace to persist sessionId after Codex exit"
      pattern: "saveWorkspace"
---

<objective>
Make createTerminal() provider-aware: branch on agent provider for command building, session management, binary detection, and provider-specific hooks. Add full Codex session discovery on exit.

Purpose: This is the core Phase 2 deliverable. After this plan, Codex agents can be spawned in Bismarck's terminal with full session resume support.

Output: Provider-aware terminal.ts that handles both Claude and Codex agents with session persistence.

**NOTE on session ID format:** CONTEXT.md says "Store rollout ID only (e.g., `rollout-abc123`)". Research (02-RESEARCH.md, Pitfall 1) found this is inaccurate — the actual Codex session identifier is a UUID (e.g., `7f9f9a2e-1b3c-4c7a-9b0e-...`) stored in the SessionMeta first line of the JSONL file. The files are *named* `rollout-*.jsonl` but the session ID inside is a UUID. This plan uses the correct UUID format per research findings. The `codex resume <UUID>` command accepts this format.
</objective>

<execution_context>
@/workspace/CLAUDE.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/1/01-01-SUMMARY.md
@.planning/phases/2/02-RESEARCH.md
@src/main/terminal.ts
@src/shared/types.ts
@src/main/exec-utils.ts
@src/main/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add helper functions and command builders</name>
  <files>src/main/terminal.ts</files>
  <action>
Add new imports, Codex session helpers, and provider-specific command builders to terminal.ts. This task adds new code only — no modification of existing functions.

**NOTE:** This task runs AFTER Plan 02-01 has cleaned up dead code (trust prompt, accept-mode cycling, autoAcceptMode). Line references assume Plan 02-01 is complete.

**Step 1: Add imports.**

Add these imports alongside the existing imports at the top of terminal.ts:

```typescript
import { getAgentProvider } from '../shared/types'
import type { AgentProvider } from '../shared/types'
import { findBinary } from './exec-utils'
```

**Step 2: Add Codex session helper functions.**

Place these after the existing `claudeSessionExists` function, before the `TerminalProcess` interface.

Add `findJsonlFilesRecursive(dir: string): string[]`:
```typescript
/**
 * Recursively find all .jsonl files under a directory.
 * Used for scanning Codex session storage.
 */
function findJsonlFilesRecursive(dir: string): string[] {
  const results: string[] = []
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true })
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name)
      if (entry.isDirectory()) {
        results.push(...findJsonlFilesRecursive(fullPath))
      } else if (entry.isFile() && entry.name.endsWith('.jsonl')) {
        results.push(fullPath)
      }
    }
  } catch {
    // Directory may not exist or be inaccessible
  }
  return results
}
```

Add `codexSessionExists(sessionId: string): boolean`:
```typescript
/**
 * Check if a Codex session exists by its UUID.
 * Codex stores sessions in ~/.codex/sessions/ as JSONL files.
 * The first line is SessionMeta JSON containing the session UUID in the `id` field.
 */
function codexSessionExists(sessionId: string): boolean {
  const sessionsDir = path.join(os.homedir(), '.codex', 'sessions')
  if (!fs.existsSync(sessionsDir)) return false

  const jsonlFiles = findJsonlFilesRecursive(sessionsDir)
  for (const file of jsonlFiles) {
    try {
      const firstLine = fs.readFileSync(file, 'utf-8').split('\n')[0]
      const meta = JSON.parse(firstLine)
      // Handle both bare SessionMeta and RolloutLine envelope format
      const id = meta.id || meta.payload?.id
      if (id === sessionId) return true
    } catch {
      continue
    }
  }
  return false
}
```

Add `findCodexSessionForDirectory(directory: string): string | null`:
```typescript
/**
 * Find the most recent Codex session for a given working directory.
 * Scans ~/.codex/sessions/ recursively, reads SessionMeta from first line of each JSONL file,
 * and matches by cwd field. Returns the session UUID or null if not found.
 */
function findCodexSessionForDirectory(directory: string): string | null {
  const sessionsDir = path.join(os.homedir(), '.codex', 'sessions')
  if (!fs.existsSync(sessionsDir)) return null

  // Find all session files, sorted newest first
  const jsonlFiles = findJsonlFilesRecursive(sessionsDir)
    .map(file => ({ file, mtime: fs.statSync(file).mtimeMs }))
    .sort((a, b) => b.mtime - a.mtime)
    .map(entry => entry.file)

  for (const file of jsonlFiles) {
    try {
      const firstLine = fs.readFileSync(file, 'utf-8').split('\n')[0]
      const meta = JSON.parse(firstLine)
      // Handle both bare SessionMeta and RolloutLine envelope format
      const cwd = meta.cwd || meta.payload?.cwd
      if (cwd === directory) {
        return meta.id || meta.payload?.id || null
      }
    } catch {
      continue
    }
  }
  return null
}
```

**Step 3: Add provider-specific command builders.**

Place these after the session helpers (before TerminalProcess interface or after it — wherever feels cleanest).

Add `buildClaudeCommand`:
```typescript
/**
 * Build the Claude CLI command string.
 * Extracted from existing inline code — flag ordering preserved (flags before --resume/--session-id).
 */
function buildClaudeCommand(options: {
  sessionId?: string
  resume: boolean
  claudeFlags?: string
  initialPrompt?: string
}): string {
  let cmd = 'claude'
  if (options.claudeFlags) cmd += ` ${options.claudeFlags}`
  if (options.resume && options.sessionId) {
    cmd += ` --resume ${options.sessionId}`
  } else if (options.sessionId) {
    cmd += ` --session-id ${options.sessionId}`
  }
  if (options.initialPrompt) {
    const escaped = options.initialPrompt.replace(/'/g, "'\\''")
    cmd += ` '${escaped}'`
  }
  return cmd + '\n'
}
```

Add `buildCodexCommand`:
```typescript
/**
 * Build the Codex CLI command string.
 * New session: codex --cd <dir> [prompt]
 * Resume: codex resume <UUID> --cd <dir>
 * Directory paths are single-quoted to handle spaces.
 */
function buildCodexCommand(options: {
  directory: string
  sessionId?: string
  resume: boolean
  initialPrompt?: string
}): string {
  if (options.resume && options.sessionId) {
    return `codex resume ${options.sessionId} --cd '${options.directory}'\n`
  }
  let cmd = `codex --cd '${options.directory}'`
  if (options.initialPrompt) {
    const escaped = options.initialPrompt.replace(/'/g, "'\\''")
    cmd += ` '${escaped}'`
  }
  return cmd + '\n'
}
```

Do NOT modify createTerminal() or any existing functions in this task. Only add new code.
  </action>
  <verify>Run `npx tsc --noEmit` from /workspace. Zero errors expected. Then verify the new functions exist:
- `grep -n "buildClaudeCommand" src/main/terminal.ts` shows the function definition
- `grep -n "buildCodexCommand" src/main/terminal.ts` shows the function definition
- `grep -n "codexSessionExists" src/main/terminal.ts` shows the function definition
- `grep -n "findCodexSessionForDirectory" src/main/terminal.ts` shows the function definition
- `grep -n "findJsonlFilesRecursive" src/main/terminal.ts` shows the function definition
- `grep -n "getAgentProvider" src/main/terminal.ts` shows the import
- `grep -n "findBinary" src/main/terminal.ts` shows the import
  </verify>
  <done>All helper functions and command builders added. TypeScript compiles. No existing code modified.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor createTerminal to use provider branching</name>
  <files>src/main/terminal.ts</files>
  <action>
Refactor createTerminal() to branch on agent provider. Replace the inline Claude command construction with calls to the helper functions from Task 1.

**Step 1: Add provider detection and binary check.**

After the directory validation block (the `if (!fs.existsSync(cwd))` check), add:

```typescript
  // Determine agent provider
  const provider = getAgentProvider(workspace)

  // Check if codex binary is available
  let skipCommand = false
  if (provider === 'codex') {
    const codexPath = findBinary('codex')
    if (!codexPath) {
      skipCommand = true
    }
  }
```

**Step 2: Replace inline Claude command construction with provider-aware logic.**

Delete the entire block from `// Get or generate session ID for Claude session persistence` through `claudeCmd += '\n'` (the block that constructs `claudeCmd`). This is roughly lines 92-125 in the current file (after Plan 01 cleanup).

Replace with this provider-aware session resolution and command building:

```typescript
  // Build provider-specific agent command
  let agentCmd = ''

  if (provider === 'claude') {
    // Claude session management (unchanged behavior)
    let sessionId = workspace.sessionId
    let resume = false
    if (sessionId && claudeSessionExists(sessionId)) {
      resume = true
    } else if (!sessionId) {
      sessionId = crypto.randomUUID()
      saveWorkspace({ ...workspace, sessionId })
    }
    agentCmd = buildClaudeCommand({ sessionId, resume, claudeFlags, initialPrompt })
  } else if (provider === 'codex' && !skipCommand) {
    // Codex session management
    let sessionId = workspace.sessionId
    let resume = false
    if (sessionId && codexSessionExists(sessionId)) {
      resume = true
    }
    agentCmd = buildCodexCommand({ directory: cwd, sessionId, resume, initialPrompt })
  }
```

**Step 3: Update shell prompt handler to use `agentCmd` instead of `claudeCmd`.**

Find the prompt detection handler (`const promptHandler = (data: string) => {`). Replace the `ptyProcess.write(claudeCmd)` call inside `setTimeout` with:

```typescript
    setTimeout(() => {
      if (skipCommand) {
        // Codex binary not found — write styled error to terminal
        ptyProcess.write("printf '\\n\\033[31m  codex not found\\033[0m\\n\\n  Install with: \\033[36mnpm install -g @openai/codex\\033[0m\\n  Or:           \\033[36mbrew install --cask codex\\033[0m\\n\\n'\n")
      } else {
        ptyProcess.write(agentCmd)
      }
    }, 100)
```

**Step 4: Update the fallback timeout (3 second) similarly.**

Find the `setTimeout(() => { if (!promptDetected)` block. Replace `ptyProcess.write(claudeCmd)` with:

```typescript
      if (skipCommand) {
        ptyProcess.write("printf '\\n\\033[31m  codex not found\\033[0m\\n\\n  Install with: \\033[36mnpm install -g @openai/codex\\033[0m\\n  Or:           \\033[36mbrew install --cask codex\\033[0m\\n\\n'\n")
      } else {
        ptyProcess.write(agentCmd)
      }
```

**Step 5: Delete the old `claudeCmd` variable.**

After all replacements, ensure there are NO remaining references to `claudeCmd` in createTerminal(). The variable is fully replaced by `agentCmd`. If the variable declaration `let claudeCmd: string` still exists, delete it.

**Important:** The `claudeFlags` parameter on createTerminal() stays. It's only used for Claude agents (passed to `buildClaudeCommand`). For Codex agents it's ignored — Codex-specific flags are a future phase concern.
  </action>
  <verify>Run `npx tsc --noEmit` from /workspace. Zero errors expected. Then verify:
- `grep -n "claudeCmd" src/main/terminal.ts` returns zero matches (fully replaced by agentCmd)
- `grep -n "agentCmd" src/main/terminal.ts` shows the variable and its usage
- `grep -n "getAgentProvider" src/main/terminal.ts` shows usage in createTerminal
- `grep -n "codex not found" src/main/terminal.ts` shows the error message
- `grep -n "skipCommand" src/main/terminal.ts` shows the flag and both usage points (prompt handler + fallback)
  </verify>
  <done>createTerminal() branches on provider for command building and session resolution. Codex binary detection writes styled error to terminal when missing. Claude behavior identical to before. No claudeCmd references remain.</done>
</task>

<task type="auto">
  <name>Task 3: Provider-aware hooks and Codex session capture on exit</name>
  <files>src/main/terminal.ts</files>
  <action>
Make the provider-specific onData hooks conditional and add Codex session capture on terminal exit.

**Step 1: Make /clear detection Claude-only.**

Find the existing /clear handler that detects `(no content)` and clears sessionId. Wrap the entire `ptyProcess.onData` block in a provider check:

```typescript
  // Detect /clear command and clear session ID so next open starts fresh
  // Claude outputs "(no content)" after /clear completes
  // Codex has no /clear equivalent (/new instead, which doesn't need session clearing)
  if (provider === 'claude') {
    ptyProcess.onData((data) => {
      if (data.includes('(no content)')) {
        const currentWorkspace = getWorkspaceById(workspaceId)
        if (currentWorkspace?.sessionId) {
          saveWorkspace({ ...currentWorkspace, sessionId: undefined })
          devLog(`[Terminal] Cleared session ID for workspace ${workspaceId} after /clear`)
        }
      }
    })
  }
```

**Step 2: Make Claude ready detection Claude-only.**

Find the existing Claude ready detection block (detects `⏵` character). Move the `claudeReadyDetected` variable inside a provider check and wrap the handler:

```typescript
  // Detect when agent is ready
  if (provider === 'claude') {
    // Claude shows the status line with ⏵ when ready
    let claudeReadyDetected = false
    ptyProcess.onData((data) => {
      if (!claudeReadyDetected && data.includes('⏵')) {
        claudeReadyDetected = true
        endTimer(`agent:claude-start:${workspaceId}`)
        if (!firstAgentReadyReported) {
          firstAgentReadyReported = true
          milestone('first-agent-ready')
        }
      }
    })
  }
```

Also, for non-Claude providers, end the timer and report ready immediately after the command is written. In the prompt handler's `setTimeout` callback, after the `ptyProcess.write(agentCmd)` line (inside the `else` branch, i.e. when `!skipCommand`), add:

```typescript
        // For non-Claude providers, report ready immediately after command write
        // (no TUI ready signal to detect — Codex's Ratatui TUI has no simple indicator)
        if (provider !== 'claude') {
          endTimer(`agent:claude-start:${workspaceId}`)
          if (!firstAgentReadyReported) {
            firstAgentReadyReported = true
            milestone('first-agent-ready')
          }
        }
```

The `claudeReadyDetected` variable that was previously declared at the outer scope should be removed (it's now scoped inside the `if (provider === 'claude')` block).

**Step 3: Add Codex session capture on terminal exit.**

Find the existing `ptyProcess.onExit` handler. Add Codex session discovery BEFORE the existing `mainWindow.webContents.send` and `terminals.delete` calls:

```typescript
  ptyProcess.onExit(({ exitCode }) => {
    // For Codex agents, discover and save the session ID on exit
    if (provider === 'codex') {
      try {
        const currentWorkspace = getWorkspaceById(workspaceId)
        if (currentWorkspace) {
          const sessionId = findCodexSessionForDirectory(currentWorkspace.directory)
          if (sessionId) {
            saveWorkspace({ ...currentWorkspace, sessionId })
            devLog(`[Terminal] Captured Codex session ${sessionId} for workspace ${workspaceId}`)
          }
        }
      } catch (err) {
        devLog(`[Terminal] Failed to capture Codex session for workspace ${workspaceId}:`, err)
      }
    }

    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('terminal-exit', terminalId, exitCode)
    }
    terminals.delete(terminalId)
  })
```

The `provider` variable is in scope from the outer `createTerminal()` function. The `findCodexSessionForDirectory` function was added in Task 1. Session capture is wrapped in try/catch so errors don't prevent normal exit cleanup.
  </action>
  <verify>Run `npx tsc --noEmit` from /workspace. Zero errors expected. Then verify:
- `grep -n "provider === 'claude'" src/main/terminal.ts` shows at least 3 matches (session resolution, /clear, ready detection)
- `grep -n "provider === 'codex'" src/main/terminal.ts` shows at least 2 matches (binary detection, session capture on exit)
- `grep -B1 "no content" src/main/terminal.ts` shows `claude` nearby (proving /clear is Claude-only)
- `grep -n "findCodexSessionForDirectory" src/main/terminal.ts` shows both the definition and usage in exit handler
- `grep -n "Captured Codex session" src/main/terminal.ts` shows the exit handler code
  </verify>
  <done>/clear detection fires only for Claude. Claude ready detection fires only for Claude. Codex agents report ready immediately after command write. Codex session UUID is captured on terminal exit via filesystem scan. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
Full verification after all three tasks:

1. `npx tsc --noEmit` passes with zero errors
2. Provider-aware command building: `grep "buildClaudeCommand\|buildCodexCommand" src/main/terminal.ts` shows both functions
3. Binary detection: `grep "findBinary.*codex" src/main/terminal.ts` shows codex detection
4. Session helpers: `grep "codexSessionExists\|findCodexSessionForDirectory\|findJsonlFilesRecursive" src/main/terminal.ts` shows all three
5. Provider branching: `grep "getAgentProvider" src/main/terminal.ts` shows usage
6. No claudeCmd remnant: `grep "claudeCmd" src/main/terminal.ts` returns zero matches
7. /clear is Claude-only: the `(no content)` check is inside a `provider === 'claude'` guard
8. Ready detection is Claude-only: the `⏵` check is inside a `provider === 'claude'` guard
9. Codex session capture on exit: `grep "Captured Codex session" src/main/terminal.ts` shows the exit handler code
10. Error message for missing codex: `grep "codex not found" src/main/terminal.ts` shows styled error
11. Directory paths quoted: `grep "cd '" src/main/terminal.ts` shows single-quoted paths in buildCodexCommand

Ensure Claude behavior is UNCHANGED by verifying:
- Claude session resolution still uses crypto.randomUUID(), --session-id, --resume
- Claude /clear detection still clears sessionId
- Claude ready detection still uses the unicode triangle character
</verification>

<success_criteria>
- Codex agents spawn with `codex --cd <dir>` for new sessions
- Codex agents resume with `codex resume <UUID> --cd <dir>` when session exists
- Codex initial prompt passed as `codex --cd <dir> '<prompt>'`
- Missing codex binary shows styled error in terminal (no crash, no IPC error)
- /clear detection is Claude-only
- Ready detection is Claude-only (Codex ready on command write)
- Codex session UUID captured on terminal exit via ~/.codex/sessions/ scan
- Claude agent behavior is 100% identical to before
- TypeScript compiles with zero errors
- Directory paths are properly quoted in codex commands
</success_criteria>

<output>
After completion, create `.planning/phases/2/02-02-SUMMARY.md`
</output>
