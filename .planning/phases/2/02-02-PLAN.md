---
phase: 02-terminal-spawning
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/main/terminal.ts
autonomous: true

must_haves:
  truths:
    - "Codex agents spawn with `codex --cd <dir>` command when provider is 'codex'"
    - "Codex agents with initial prompt spawn with `codex --cd <dir> '<prompt>'`"
    - "Codex agents with existing sessionId resume with `codex resume <UUID> --cd <dir>`"
    - "Claude agents spawn identically to before (no behavioral change)"
    - "If codex binary not found, styled error message appears in terminal output"
    - "/clear detection only fires for Claude agents, not Codex"
    - "Claude ready detection (unicode triangle) only fires for Claude agents, not Codex"
    - "Codex session is discovered on terminal exit by scanning ~/.codex/sessions/"
  artifacts:
    - path: "src/main/terminal.ts"
      provides: "Provider-aware createTerminal with Codex command building, session management, and binary detection"
      exports: ["createTerminal"]
      contains: "buildCodexCommand"
  key_links:
    - from: "src/main/terminal.ts"
      to: "src/shared/types.ts"
      via: "imports getAgentProvider, AgentProvider"
      pattern: "getAgentProvider"
    - from: "src/main/terminal.ts"
      to: "src/main/exec-utils.ts"
      via: "imports findBinary for codex detection"
      pattern: "findBinary"
    - from: "src/main/terminal.ts"
      to: "src/main/config.ts"
      via: "saveWorkspace to persist sessionId after Codex exit"
      pattern: "saveWorkspace"
---

<objective>
Make createTerminal() provider-aware: branch on agent provider for command building, session management, binary detection, and provider-specific hooks. Add full Codex session discovery on exit.

Purpose: This is the core Phase 2 deliverable. After this plan, Codex agents can be spawned in Bismarck's terminal with full session resume support.

Output: Provider-aware terminal.ts that handles both Claude and Codex agents with session persistence.
</objective>

<execution_context>
@/workspace/CLAUDE.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/1/01-01-SUMMARY.md
@.planning/phases/2/02-RESEARCH.md
@src/main/terminal.ts
@src/shared/types.ts
@src/main/exec-utils.ts
@src/main/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Provider-aware command building and binary detection</name>
  <files>src/main/terminal.ts</files>
  <action>
Transform `createTerminal()` to branch on agent provider. This task modifies the top half of createTerminal() (command construction and session management) and adds helper functions. The existing PTY spawn, data forwarding, and exit handling stay in place.

**Step 1: Add imports.**

Add to the existing imports at the top of terminal.ts:
```typescript
import { getAgentProvider } from '../shared/types'
import type { AgentProvider } from '../shared/types'
import { findBinary } from './exec-utils'
```

**Step 2: Add Codex session helper functions** (place after the existing `claudeSessionExists` function, before the `TerminalProcess` interface).

Add `codexSessionExists(sessionId: string): boolean`:
- Takes a session UUID string
- Checks `path.join(os.homedir(), '.codex', 'sessions')` exists
- Recursively finds all `*.jsonl` files under that directory
- For each file, reads only the first line, parses as JSON
- Extracts ID via `meta.id || meta.payload?.id` (handles both bare SessionMeta and RolloutLine envelope formats)
- Returns true if any file's ID matches the given sessionId
- Returns false on any error (catch and continue)

Add `findCodexSessionForDirectory(directory: string): string | null`:
- Takes a directory path string
- Checks `path.join(os.homedir(), '.codex', 'sessions')` exists; return null if not
- Recursively finds all `*.jsonl` files under that directory
- Sorts by file mtime descending (newest first) using `fs.statSync(file).mtimeMs`
- For each file, reads only the first line (use `fs.readFileSync(file, 'utf-8').split('\n')[0]`)
- Parses as JSON, extracts cwd via `meta.cwd || meta.payload?.cwd`
- If cwd matches the directory parameter, return `meta.id || meta.payload?.id`
- Return null if no match found
- Wrap everything in try/catch, return null on error

Add `findJsonlFilesRecursive(dir: string): string[]`:
- Recursively walks the directory tree under `dir`
- Returns full paths of all files ending in `.jsonl`
- Uses `fs.readdirSync` with `{ withFileTypes: true }` for efficiency
- Recurse into subdirectories, collect files
- Return empty array on any error

**Step 3: Add provider-specific command builders** (place after the session helpers).

Add `buildClaudeCommand(workspace, sessionId, initialPrompt, claudeFlags)`:
- Extract the existing Claude command construction logic from createTerminal() (lines 92-125 after Plan 01's cleanup)
- Parameters: `workspace: { sessionId?: string; directory: string }`, `sessionId: string | undefined`, `initialPrompt: string | undefined`, `claudeFlags: string | undefined`
- Returns `string` (the full command including trailing `\n`)
- Logic: if sessionId and claudeSessionExists(sessionId), build `claude [flags] --resume <id>\n`. Otherwise generate new UUID via `crypto.randomUUID()`, build `claude [flags] --session-id <id>\n`. Append initial prompt if provided (single-quote escaped). Return the sessionId used (for saving back to workspace).
- Actually, to keep it simpler and avoid returning two values, make this function return just the command string, and handle sessionId generation/saving in the caller. Better approach: make buildClaudeCommand take the resolved sessionId and resumeMode as inputs.

Revised approach -- keep command builders simple, do session resolution in createTerminal:

```typescript
function buildClaudeCommand(options: {
  sessionId?: string,
  resume: boolean,
  claudeFlags?: string,
  initialPrompt?: string,
}): string {
  let cmd = 'claude'
  if (options.claudeFlags) cmd += ` ${options.claudeFlags}`
  if (options.resume && options.sessionId) {
    cmd += ` --resume ${options.sessionId}`
  } else if (options.sessionId) {
    cmd += ` --session-id ${options.sessionId}`
  }
  if (options.initialPrompt) {
    const escaped = options.initialPrompt.replace(/'/g, "'\\''")
    cmd += ` '${escaped}'`
  }
  return cmd + '\n'
}
```

Add `buildCodexCommand(options)`:
```typescript
function buildCodexCommand(options: {
  directory: string,
  sessionId?: string,
  resume: boolean,
  initialPrompt?: string,
}): string {
  if (options.resume && options.sessionId) {
    // Resume: codex resume <UUID> --cd <dir>
    let cmd = `codex resume ${options.sessionId} --cd ${options.directory}`
    return cmd + '\n'
  }
  // New session: codex --cd <dir> [prompt]
  let cmd = `codex --cd ${options.directory}`
  if (options.initialPrompt) {
    const escaped = options.initialPrompt.replace(/'/g, "'\\''")
    cmd += ` '${escaped}'`
  }
  return cmd + '\n'
}
```

**Step 4: Refactor createTerminal() to use provider branching.**

After the directory validation (cwd check), determine the provider:
```typescript
const provider = getAgentProvider(workspace)
```

**Binary detection for Codex** (per user decision: check at spawn time, write styled error to terminal if not found):
```typescript
if (provider === 'codex') {
  const codexPath = findBinary('codex')
  if (!codexPath) {
    // Write styled error message directly to terminal output
    const errorMsg = '\r\n\x1b[31m  codex not found\x1b[0m\r\n\r\n'
      + '  Install with: \x1b[36mnpm install -g @openai/codex\x1b[0m\r\n'
      + '  Or:           \x1b[36mbrew install --cask codex\x1b[0m\r\n\r\n'
    // Still need to spawn PTY so terminal shows the error
    // We'll handle this after PTY spawn by writing the error and NOT writing any command
  }
}
```

Actually, per the user decision, the terminal stays open showing the error. The cleanest approach: spawn the PTY, detect the shell prompt, and instead of writing a command, write the error message to the renderer directly and return. But the PTY still needs to exist. Better: spawn PTY as normal, but set a flag `skipCommand = true` and write the error into the terminal data stream after shell prompt is detected.

Refined approach for binary detection:
```typescript
let agentCmd: string = ''
let skipCommand = false

if (provider === 'codex') {
  const codexPath = findBinary('codex')
  if (!codexPath) {
    skipCommand = true
    // We'll write error message after PTY spawns
  }
}
```

**Session resolution** (provider-specific):

For Claude (same as current logic):
```typescript
if (provider === 'claude') {
  let sessionId = workspace.sessionId
  let resume = false
  if (sessionId && claudeSessionExists(sessionId)) {
    resume = true
  } else if (!sessionId) {
    sessionId = crypto.randomUUID()
    saveWorkspace({ ...workspace, sessionId })
  }
  agentCmd = buildClaudeCommand({ sessionId, resume, claudeFlags, initialPrompt })
}
```

For Codex:
```typescript
if (provider === 'codex' && !skipCommand) {
  let sessionId = workspace.sessionId
  let resume = false
  if (sessionId && codexSessionExists(sessionId)) {
    resume = true
  }
  // If no session or session not found, start fresh (Codex generates its own session IDs)
  agentCmd = buildCodexCommand({ directory: cwd, sessionId, resume, initialPrompt })
}
```

**Replace the hardcoded `claudeCmd` variable** throughout the rest of createTerminal() with `agentCmd`. The shell prompt handler and fallback timeout both currently reference `claudeCmd` -- change to `agentCmd`. When `skipCommand` is true, write the error message instead of a command:

In the prompt handler:
```typescript
const promptHandler = (data: string) => {
  if (!promptDetected && (
    /[$%>]\s*$/.test(data) ||
    /\w+@\w+/.test(data) ||
    data.includes(os.userInfo().username)
  )) {
    promptDetected = true
    endTimer(`agent:shell-prompt:${workspaceId}`)
    startTimer(`agent:claude-start:${workspaceId}`, 'agent')
    setTimeout(() => {
      if (skipCommand) {
        // Binary not found -- write error to terminal
        const errorMsg = '\r\n\x1b[31m  codex not found\x1b[0m\r\n\r\n'
          + '  Install with: \x1b[36mnpm install -g @openai/codex\x1b[0m\r\n'
          + '  Or:           \x1b[36mbrew install --cask codex\x1b[0m\r\n\r\n'
        ptyProcess.write(`echo -e "${errorMsg.replace(/\n/g, '\\n')}"\n`)
        // Actually, cleaner: just write the ANSI directly to the pty
        ptyProcess.write(`printf '\\033[31m  codex not found\\033[0m\\n\\n  Install with: \\033[36mnpm install -g @openai/codex\\033[0m\\n  Or:           \\033[36mbrew install --cask codex\\033[0m\\n\\n'\n`)
      } else {
        ptyProcess.write(agentCmd)
      }
    }, 100)
  }
}
```

Wait, that's getting complicated with escaping. Simpler approach -- just write a clear shell echo command:
```typescript
if (skipCommand) {
  ptyProcess.write("echo ''\n")
  ptyProcess.write("echo '  \\x1b[31mcodex not found\\x1b[0m'\n")
  ptyProcess.write("echo ''\n")
  ptyProcess.write("echo '  Install with: npm install -g @openai/codex'\n")
  ptyProcess.write("echo '  Or:           brew install --cask codex'\n")
  ptyProcess.write("echo ''\n")
}
```

Actually simplest and most reliable: use `printf` with literal ANSI codes since the terminal is xterm-256color:
```typescript
if (skipCommand) {
  ptyProcess.write("printf '\\n\\033[31m  codex not found\\033[0m\\n\\n  Install with: \\033[36mnpm install -g @openai/codex\\033[0m\\n  Or:           \\033[36mbrew install --cask codex\\033[0m\\n\\n'\n")
}
```

This writes the error into the shell which renders it styled in the terminal. Terminal stays open (shell is still running).

Also update the fallback timeout (3 second) to use the same skipCommand logic.

**Step 5: Rename benchmark timer** from `agent:claude-start` to `agent:agent-start` (or keep it as-is since it's just an internal label -- your discretion. Keeping it as `agent:claude-start` is fine since it's an opaque string).

Keep the benchmark timer names as-is for backward compatibility.

**Important:** The `agentCmd` variable replaces `claudeCmd` everywhere in createTerminal(). Delete the old `claudeCmd` variable declaration and all the old inline command construction code (lines 92-125).
  </action>
  <verify>Run `npx tsc --noEmit` from /workspace. Zero errors expected. Then verify:
- `grep -n "getAgentProvider" src/main/terminal.ts` should show the import and usage
- `grep -n "findBinary" src/main/terminal.ts` should show the import and codex detection call
- `grep -n "buildCodexCommand" src/main/terminal.ts` should show the function definition
- `grep -n "buildClaudeCommand" src/main/terminal.ts` should show the function definition
- `grep -n "codexSessionExists" src/main/terminal.ts` should show the function definition
- `grep -n "findCodexSessionForDirectory" src/main/terminal.ts` should show the function definition
- `grep -n "claudeCmd" src/main/terminal.ts` should return zero matches (replaced by agentCmd)
- `grep -n "codex not found" src/main/terminal.ts` should show the error message
  </verify>
  <done>createTerminal() branches on provider for command building and session resolution. Codex binary detection writes styled error to terminal. Helper functions for Codex session lookup exist. Claude behavior is identical to before.</done>
</task>

<task type="auto">
  <name>Task 2: Provider-aware hooks and Codex session capture on exit</name>
  <files>src/main/terminal.ts</files>
  <action>
Make the provider-specific onData hooks conditional and add Codex session capture on terminal exit.

**Step 1: Make /clear detection Claude-only.**

The existing /clear handler (currently around line 170 after Plan 01 cleanup) detects `(no content)` and clears sessionId. Wrap this in a provider check:

```typescript
// Detect /clear command and clear session ID so next open starts fresh
// Claude outputs "(no content)" after /clear completes
// Codex has no /clear equivalent (/new instead, which doesn't need session clearing)
if (provider === 'claude') {
  ptyProcess.onData((data) => {
    if (data.includes('(no content)')) {
      const currentWorkspace = getWorkspaceById(workspaceId)
      if (currentWorkspace?.sessionId) {
        saveWorkspace({ ...currentWorkspace, sessionId: undefined })
        devLog(`[Terminal] Cleared session ID for workspace ${workspaceId} after /clear`)
      }
    }
  })
}
```

**Step 2: Make Claude ready detection Claude-only.**

The existing Claude ready detection (detects `⏵` character) should only fire for Claude agents. Codex uses a full-screen Ratatui TUI with no simple ready indicator. Per user decision: "terminal is ready when PTY spawns" for Codex.

```typescript
// Detect when Claude is ready (shows the status line with triangle)
// Codex: no equivalent detection -- ready when PTY spawns
if (provider === 'claude') {
  let claudeReadyDetected = false
  ptyProcess.onData((data) => {
    if (!claudeReadyDetected && data.includes('⏵')) {
      claudeReadyDetected = true
      endTimer(`agent:claude-start:${workspaceId}`)
      if (!firstAgentReadyReported) {
        firstAgentReadyReported = true
        milestone('first-agent-ready')
      }
    }
  })
} else if (provider === 'codex') {
  // For Codex, report ready immediately after command is written
  // (done in shell prompt handler -- end timer there for Codex)
}
```

For Codex, end the `agent:claude-start` timer right after writing the command in the prompt handler. Modify the prompt handler to add:
```typescript
setTimeout(() => {
  if (skipCommand) {
    // ... error handling ...
  } else {
    ptyProcess.write(agentCmd)
    // For non-Claude providers, mark agent as ready immediately after command write
    if (provider !== 'claude') {
      endTimer(`agent:claude-start:${workspaceId}`)
      if (!firstAgentReadyReported) {
        firstAgentReadyReported = true
        milestone('first-agent-ready')
      }
    }
  }
}, 100)
```

Move the `claudeReadyDetected` variable and its handler inside the `if (provider === 'claude')` block (it's already scoped there in the new code).

**Step 3: Add Codex session capture on terminal exit.**

In the process exit handler (`ptyProcess.onExit`), add Codex-specific session discovery:

```typescript
ptyProcess.onExit(({ exitCode }) => {
  // For Codex agents, discover and save the session ID on exit
  if (provider === 'codex') {
    try {
      const currentWorkspace = getWorkspaceById(workspaceId)
      if (currentWorkspace) {
        const sessionId = findCodexSessionForDirectory(currentWorkspace.directory)
        if (sessionId) {
          saveWorkspace({ ...currentWorkspace, sessionId })
          devLog(`[Terminal] Captured Codex session ${sessionId} for workspace ${workspaceId}`)
        }
      }
    } catch (err) {
      devLog(`[Terminal] Failed to capture Codex session for workspace ${workspaceId}:`, err)
    }
  }

  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('terminal-exit', terminalId, exitCode)
  }
  terminals.delete(terminalId)
})
```

The Codex session capture runs BEFORE notifying the renderer of exit and removing from the terminals map. This ensures the workspace is updated before any UI state change.

**Important notes:**
- The `provider` variable must be in scope for the exit handler. It already will be since it's declared in the outer createTerminal() function scope.
- The `findCodexSessionForDirectory` function from Task 1 handles all the recursive scanning and format detection.
- Session capture is wrapped in try/catch so errors don't prevent normal exit cleanup.
  </action>
  <verify>Run `npx tsc --noEmit` from /workspace. Zero errors expected. Then verify:
- `grep -n "provider === 'claude'" src/main/terminal.ts` should show at least 2-3 matches (for /clear, ready detection, session resolution)
- `grep -n "provider === 'codex'" src/main/terminal.ts` should show at least 2 matches (binary detection, session capture on exit)
- `grep -n "findCodexSessionForDirectory" src/main/terminal.ts` should show the function definition and usage in exit handler
- Verify /clear handler is inside a provider check: `grep -B1 "no content" src/main/terminal.ts` should show `claude` nearby
- Verify exit handler has codex session capture: `grep -A3 "onExit" src/main/terminal.ts` should show codex-related code
  </verify>
  <done>/clear detection fires only for Claude. Claude ready detection fires only for Claude. Codex agents report ready immediately after command write. Codex session ID is captured on terminal exit via filesystem scan. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
Full verification after both tasks:

1. `npx tsc --noEmit` passes with zero errors
2. Provider-aware command building: `grep "buildClaudeCommand\|buildCodexCommand" src/main/terminal.ts` shows both functions
3. Binary detection: `grep "findBinary.*codex" src/main/terminal.ts` shows codex detection
4. Session helpers: `grep "codexSessionExists\|findCodexSessionForDirectory\|findJsonlFilesRecursive" src/main/terminal.ts` shows all three
5. Provider branching: `grep "getAgentProvider" src/main/terminal.ts` shows usage
6. No claudeCmd remnant: `grep "claudeCmd" src/main/terminal.ts` returns zero matches
7. /clear is Claude-only: the `(no content)` check is inside a `provider === 'claude'` guard
8. Ready detection is Claude-only: the `⏵` check is inside a `provider === 'claude'` guard
9. Codex session capture on exit: `grep "Captured Codex session" src/main/terminal.ts` shows the exit handler code
10. Error message for missing codex: `grep "codex not found" src/main/terminal.ts` shows styled error

Ensure Claude behavior is UNCHANGED by verifying:
- Claude session resolution still uses crypto.randomUUID(), --session-id, --resume
- Claude /clear detection still clears sessionId
- Claude ready detection still uses the unicode triangle character
</verification>

<success_criteria>
- Codex agents spawn with `codex --cd <dir>` for new sessions
- Codex agents resume with `codex resume <UUID> --cd <dir>` when session exists
- Codex initial prompt passed as `codex --cd <dir> '<prompt>'`
- Missing codex binary shows styled error in terminal (no crash, no IPC error)
- /clear detection is Claude-only
- Ready detection is Claude-only (Codex ready on command write)
- Codex session UUID captured on terminal exit via ~/.codex/sessions/ scan
- Claude agent behavior is 100% identical to before
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/2/02-02-SUMMARY.md`
</output>
