<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bismarck</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@800&display=swap" rel="stylesheet">
    <style>
      #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.3s ease-out;
      }
      #splash-screen.hidden {
        opacity: 0;
        pointer-events: none;
      }
      #splash-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body style="margin: 0; padding: 0; background-color: #1a1a1a;">
    <!-- Splash screen with particle animation -->
    <div id="splash-screen">
      <canvas id="splash-canvas"></canvas>
    </div>

    <div id="root"></div>

    <!-- Inline splash screen animation - no dependencies, runs immediately -->
    <script>
      (function() {
        const canvas = document.getElementById('splash-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Full viewport sizing
        const W = window.innerWidth;
        const H = window.innerHeight;
        canvas.width = W;
        canvas.height = H;

        // Seeded random for consistency
        let seed = 1871;
        function random(min = 0, max = 1) {
          seed = (seed * 9301 + 49297) % 233280;
          return min + (seed / 233280) * (max - min);
        }

        // Dynamic logo scale based on viewport (logo is ~24x32 units)
        const logoScale = Math.min(W, H) * 0.008;
        const logoOffsetX = W/2 - 12*logoScale;
        const logoOffsetY = H/2 - 16*logoScale;

        // Pickelhaube shape test - returns true if point is inside logo
        function insideLogo(x, y) {
          const lx = (x - logoOffsetX) / logoScale;
          const ly = (y - logoOffsetY) / logoScale;

          // Spike (triangle)
          if (ly >= 0 && ly < 8) {
            const hw = 2 * (ly / 8);
            if (lx >= 12 - hw && lx <= 12 + hw) return true;
          }

          // Main dome
          if (ly >= 8 && ly <= 26) {
            const t = (ly - 8) / 18;
            let hw;
            if (t < 0.33) hw = 4 + t * 12;
            else if (t < 0.67) hw = 8;
            else hw = 8 * (1 - (t - 0.67) / 0.33);
            if (lx >= 12 - hw && lx <= 12 + hw) return true;
          }

          // Left brim
          if (lx >= 2 && lx <= 7 && ly >= 15 && ly <= 22) return true;

          // Right brim
          if (lx >= 17 && lx <= 22 && ly >= 15 && ly <= 22) return true;

          // Chin strap
          if (ly >= 24 && ly <= 30 && lx >= 6 && lx <= 18) {
            const t = (lx - 6) / 12;
            const strapY = 24 + 6 * 4 * t * (1 - t);
            if (Math.abs(ly - strapY) < 2.5) return true;
          }

          return false;
        }

        // Pre-calculate valid logo points (do this once, fast)
        const logoPoints = [];
        const step = logoScale * 0.8; // Sample grid
        for (let x = logoOffsetX; x < logoOffsetX + 24 * logoScale; x += step) {
          for (let y = logoOffsetY; y < logoOffsetY + 32 * logoScale; y += step) {
            if (insideLogo(x, y)) {
              logoPoints.push({ x, y });
            }
          }
        }

        // Create particles by sampling from valid points
        const PARTICLE_COUNT = Math.min(800, logoPoints.length);
        const particles = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const pt = logoPoints[Math.floor(random(0, logoPoints.length))];
          // Add small random offset for organic feel
          const x = pt.x + random(-3, 3);
          const y = pt.y + random(-3, 3);

          particles.push({
            x: x,
            y: y,
            homeX: x,
            homeY: y,
            vx: random(-0.3, 0.3),
            vy: random(-0.3, 0.3),
            alpha: random(0.5, 1),
            size: random(1.2, 2.2),
            phase: random(0, Math.PI * 2)
          });
        }

        // Ring configuration - particles orbit around the helmet
        const ringRadius = logoScale * 24;  // Further outside the helmet shape
        const ringCenterX = W / 2;
        const ringCenterY = H / 2 + logoScale * 2;  // Slightly lower (helmet center is offset)
        const RING_PARTICLE_COUNT = 120;  // More particles for thicker ring
        const ringParticles = [];

        for (let i = 0; i < RING_PARTICLE_COUNT; i++) {
          const angle = (i / RING_PARTICLE_COUNT) * Math.PI * 2;
          const radiusOffset = random(-4, 4);  // 2-3 particle thickness variation
          ringParticles.push({
            angle: angle,
            radiusOffset: radiusOffset,
            alpha: random(0.35, 0.65),  // More visible
            size: random(1.2, 1.8),
            speedOffset: random(-0.003, 0.003)  // Small speed variation for organic feel
          });
        }

        let time = 0;
        let animationId;

        function animate() {
          // Clear canvas
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(0, 0, W, H);

          time += 0.03;

          // Global pulse for loading indicator feel
          const pulse = Math.sin(time * 2) * 0.3 + 0.7;  // 0.4 to 1.0

          for (const p of particles) {
            // Strong spring force back to home position - keep helmet stable
            const dx = p.homeX - p.x;
            const dy = p.homeY - p.y;

            // Spring force - stronger to keep particles near home
            const springForce = 0.08;
            p.vx += dx * springForce;
            p.vy += dy * springForce;

            // Very subtle wandering motion (individual rhythm)
            const wanderStrength = 0.03;
            p.vx += Math.sin(time * 1.5 + p.phase) * wanderStrength;
            p.vy += Math.cos(time * 1.2 + p.phase * 1.3) * wanderStrength;

            // Heavy damping for stability
            p.vx *= 0.85;
            p.vy *= 0.85;

            // Update position
            p.x += p.vx;
            p.y += p.vy;

            // Draw particle with pulsing brightness
            const brightness = pulse * p.alpha;
            ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw rotating ring particles
          for (const rp of ringParticles) {
            // Rotate clockwise (positive angle increment) - visibly fast
            rp.angle += 0.025 + rp.speedOffset;  // ~4 second revolution, clearly visible

            const r = ringRadius + rp.radiusOffset;
            const x = ringCenterX + Math.cos(rp.angle) * r;
            const y = ringCenterY + Math.sin(rp.angle) * r;

            ctx.fillStyle = `rgba(255, 255, 255, ${rp.alpha * pulse})`;
            ctx.beginPath();
            ctx.arc(x, y, rp.size, 0, Math.PI * 2);
            ctx.fill();
          }

          animationId = requestAnimationFrame(animate);
        }

        // Start animation
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, W, H);
        animate();

        // Minimum display time tracking
        const MIN_DISPLAY_MS = 3000;
        const startTime = Date.now();
        let appReady = false;
        let dismissed = false;

        function dismissSplash() {
          if (dismissed) return;
          const elapsed = Date.now() - startTime;

          // MUST wait minimum time
          if (elapsed < MIN_DISPLAY_MS) {
            setTimeout(dismissSplash, MIN_DISPLAY_MS - elapsed + 50);
            return;
          }
          if (!appReady) return;

          dismissed = true;
          const splash = document.getElementById('splash-screen');
          if (splash) {
            splash.classList.add('hidden');
            setTimeout(() => {
              splash.remove();
              cancelAnimationFrame(animationId);
            }, 300);
          }
        }

        // Observe when React mounts
        const root = document.getElementById('root');
        if (root && root.children.length > 0) {
          appReady = true;
          dismissSplash();
        } else {
          const observer = new MutationObserver(() => {
            if (root.children.length > 0) {
              appReady = true;
              observer.disconnect();
              dismissSplash();
            }
          });
          observer.observe(root, { childList: true });
        }

        // Fallback: hide after 10 seconds
        setTimeout(() => {
          appReady = true;
          dismissSplash();
        }, 10000);
      })();
    </script>

    <script type="module" src="/src/renderer/main.tsx"></script>
  </body>
</html>
